# 响应系统实现思路分析与总结

- [x] 响应系统的作用与实现
  - [x] effect 副作用函数
  - [x] 设计一个基本的响应系统
    - [x] bucket(WeakMap) | Obj -> depsMap(Map) | key -> deps(Set) | effect
  - [x] cleanup 
    - [x] 出现的场景
    - [x] 解决方案&实现
  - [x] 如何嵌套 effect 与 effect栈
    - [x] 嵌套effect 的场景 - vue组件嵌套
    - [x] 如何解决 activeEffect 正确指向 对应的effect (在嵌套effect 中) - 使用 effectStack = []
  - [ ] 如何避免无限递归循环
    - [ ] 什么时候会出现无限递归循环
    - [ ] 如何解决
  - [ ] 调度执行
    - [ ] scheduler 解决的问题有哪些？
    - [ ] 如何实现 scheduler
  - [ ] computed && lazy && dirty
    - [ ] computed 有哪些特性
    - [ ] 懒执行- lazy如何实现
    - [ ] 缓存功能的实现 - dirty
  - [ ] watch
    - [ ] watch 基本实现 (watch(source, cb))
    - [ ] 立即执行的watch immediate: true
    - [ ] 回调执行时机 flush: pre|post|sync
    - [ ] 过期的副作用处理 onInvalidate （**先跳过**）
- [ ] 非原始值的响应式方案实现
  - [ ] 理解 Proxy 和 Reflect
  - [ ] JavaScript 对象以及 Proxy 的工作原理
  - [ ] 如何代理 Object 
  - [ ] 合理地触发响应
    - [ ] 1. 值没有发生变化，无需触发响应（特殊值的处理，NaN === NaN  --> false）
    - [ ] 2. 从原型上继承属性的情况（原型引起的更新，避免不必要的更新操作）
  - [ ] 深浅响应
    - [ ] 区别
    - [ ] shallowReactive
    - [ ] reactive
  - [ ] 只读与浅只读
    - [ ] 区别
    - [ ] readonly
    - [ ] shallowReadonly
  - [ ] 代理数组
    - [ ] 数组的索引和length
    - [ ] 遍历数组
    - [ ] 数组的查找方法 include, indexOf ……
    - [ ] 隐式修改数组长度的原型方案 push, pop……
  - [ ] 代理 Set 和 Map (**先跳过**)
  
- [ ] 原始值的响应式方案实现
  - [ ] ref
    - [ ] 出现的原因
    - [ ] 解决了哪些问题
    - [ ] ref 实现
    - [ ] 响应丢失的问题出现的原因以及如何解决？
    - [ ] 自动脱ref
      - [ ] 为何要自动脱ref, 出现的愿景是什么？
      - [ ] 如何实现